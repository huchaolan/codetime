# 设计原则和思想

## 01当谈论面向对象的时候，我们到底在谈论什么

1. 1960年出现，类和对象是面向对象编程的基础概念
2. C++出现带动了面向对象编程流程，现在大部分的编程语言都是面向对象编程
3. 面向对象种编程范式或者风格，以类或者对象为代码基本单元，将封装，抽象，继承，多态四个特性作为代码设计和实现基础
4. 不用面向对象编程实际行也可以进行面向对象编程，使用面向对象开发语言可能写出来不是面向对象编程

### 如何判定编程语言是否面向对象

1. 面向对象编程是很老概念（1960），概念在不停的演化，比如Go就没有继承
2. 编程语言支持类或对象的语法概念，就可以认定面向对象的语言了

### 什么是面向对学校分析和面向对象设计

1. 3个面向对象的概念
OOA（Object Oriented Analysis)
OOD（Object Oriented Design)
OOP（Object Oriented Programming)

2. 3个概念基本从字面上理解，但不要过度解读
3. 围绕着对象或类来做需求分析和设计的，最终的产出是类的设计(属性和方法)
4. OOA就是该清楚做什么，OOD搞清楚怎么做，OOP就是将前面两者翻译成代码的过程

### 什么是UML，是否需要UML

1. 什么是UML
UML(Unified Model Language) 统一建模语言
2. 学习UML的成本很高，大部分情况下以方便沟通为主。

## 02封装、抽象、继承、多态分别可以解决哪些编程问题

### 封装(Encapsulation)

1. 信息隐藏或者数据访问保护，不是所有的数据都有set和get方法，要对不能访问的属性删除get方法

### 抽象(Abstraction)

1. 如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并需要知道这些功能是如何实现的
2. 常用接口类或者抽象类来实现
3. 抽象是一个非常通用的设计思想，用于封装复杂性有效手段，然后调用者忽略非关键性细节，不止用在编程也可以用于架构设计等方面
4. 抽象可以在编程的各个方面，比如getAliyunPictureUrl是一个比较具体的方法名称，但是如果后续云端跟换了命名就要修改，所以叫做getPictureUrl很合理

### 继承(Inheritance)

1. 继承可以是单继承和多继承，java只支持单继承，多继承可以使用内部类等
2. 继承最大好处是代码复用
3. 多用组合少用继承

### 多态

1. 子类可以替换父类，在运行时张调用父类的方法实际上执行子类的方法
2. 实现方法继承加方法重写，接口类，duck-typing语法(类型推导，不在乎真正实体，只要有行为就可以调用)

## 03面向对象相比面向过程有哪些优势？面向过程真的过时了吗

***警惕使用面向对象编程语言来开发就是面向对象编程，实际上还是用面向过程编程***

### 面向对象编程的优势

#### OOP更能够应对大规模复杂程序的开发

+ 面向对象开发的优势
面向过程:当需求足够简单，处理只有一条主线，面向过程反倒有优势
面向对象:不急于将需求拆解为一个个方法，考虑如何给业务建模，将需求翻译成类，如何给类之间建立交互关系，这些工作不需要考虑错综复杂的处理流程，完成类的设计后，再像搭积木一样，按照处理流程将类组装起来形成整个程序。

+ 面向对象语言的优势
面向对象语言使用类来组织函数和数据结构的关系，是将代码模块化的有效手段
面向过程语言可以做到这些，但是前者是强制要求的，比如：Go去掉了继承特性只用组合，也叫做面向对象语言。

#### OOP风格的代码更容易复用，易扩展，易维护

面向对象拥有的四个特性保证了易复用，易扩展，易维护

1. 封装是面向对象与面向过程基本区别,基于类的代码组织，通过对外暴露有限的方法访问数据
2. 抽象隐藏了具体的实现，了解函数的具体功能，不需要了解怎么实现的
3. 继承是面向对象特有两个特性之一，两个类的相同的属性和方法就可以将它们抽取到父类中，避免了代码重复写多遍
4. 多态，在需要修改一个功能实现的时候，通过实现一个新子类的方式，重写原来的功能逻辑，用子类替换父类，在运行时调用父类方法执行时子类的实现。

#### OOP语言更加人性化，更加高级，更加智能

和二进制指令，汇编，面向过程相比，面向对象语言的编程套路，思考问题的方式更贴近人类的思维，前3者是计算机的思维方式

## 04哪些代码设计看似是面向对象，实际是面向过程的

### 滥用getter和setter方法

在设计bean类是需要属性的set方法有所保留，文中对购物车的例子

```java
public class ShoppingCart {
  private int itemsCount;
  private double totalPrice;
  private List<ShoppingCartItem> items = new ArrayList<>();

  public int getItemsCount() {
    return this.itemsCount;
  }

  public void setItemsCount(int itemsCount) {
    this.itemsCount = itemsCount;
  }

  public double getTotalPrice() {
    return this.totalPrice;
  }

  public void setTotalPrice(double totalPrice) {
    this.totalPrice = totalPrice;
  }

  public List<ShoppingCartItem> getItems() {
    return this.items;
  }

  public void addItem(ShoppingCartItem item) {
    items.add(item);
    itemsCount++;
    totalPrice += item.getPrice();
  }
}
```

1. `itemsCount`和`totalPrice`的set方法不合理，由于这两个属性是添加的物件累计而成，设置set方法可以直接修改造成`items`属性不一致
2. `items`属性的get方法不合理，由于其他两个属性都是由items积累而来但是get方法将保存items的集合返回去，外部方法可以直接修改造成数据不一致的情况，应该Collections.unmodifiableList方法返回一个不可修改的集合
3. 返回不可修改List我们还是可以通过集合遍历物件元素，而修改其中的值。

### 滥用全局变量和全局方法

1. 将很多常量集中放置到一个Constants类中，延长编译时间，增加提交代码的冲突。有两种方式化解

+ 按照功能配置划分常量:DBConstant，RedisConstant
+ 将常量写到配置的类中:DBConfig

2. Util类过于庞大的问题，根源是A，B类都用一段相同的逻辑，但是这个逻辑又不属于A和B类，比如解析url，字符串等工具类。

+ 需要设计出不同的工具类:FileUtil，IOUtil等等

### 定义数据和方法分离的类

MVC的3层结构：Controller层负责暴露接口给前端调用，Service层负责核心业务逻辑，Repository层负责数据读写，对应每层VO,BO,Entity,这个类将数据和操作分离，这类的代码我们天天写，属于贫血模式。

### 为什么容易写出面向过程风格的代码

面向过程符合人流程化思考的惯性，面向对象风格是至底而上的风格，先先将任务翻译成一个个小的模块，设计类之间的交互，最后按照流程将类组装起来完成整个任务。

## 05接口vs抽象类的区别？如何用普通的类模拟抽象类和接口

### 什么是抽象类和接口，区别在哪里

+ 如何定义抽象类

```java

// 抽象类
public abstract class Logger {
  private String name;
  private boolean enabled;
  private Level minPermittedLevel;

  public Logger(String name, boolean enabled, Level minPermittedLevel) {
    this.name = name;
    this.enabled = enabled;
    this.minPermittedLevel = minPermittedLevel;
  }

  public void log(Level level, String message) {
    boolean loggable = enabled && (minPermittedLevel.intValue() <= level.intValue());
    if (!loggable) return;
    doLog(level, message);
  }

  protected abstract void doLog(Level level, String message);
}
// 抽象类的子类：输出日志到文件
public class FileLogger extends Logger {
  private Writer fileWriter;

  public FileLogger(String name, boolean enabled,
    Level minPermittedLevel, String filepath) {
    super(name, enabled, minPermittedLevel);
    this.fileWriter = new FileWriter(filepath);
  }

  @Override
  public void doLog(Level level, String mesage) {
    // 格式化 level 和 message, 输出到日志文件
    fileWriter.write(...);
  }
}
// 抽象类的子类: 输出日志到消息中间件 (比如 kafka)
public class MessageQueueLogger extends Logger {
  private MessageQueueClient msgQueueClient;

  public MessageQueueLogger(String name, boolean enabled,
    Level minPermittedLevel, MessageQueueClient msgQueueClient) {
    super(name, enabled, minPermittedLevel);
    this.msgQueueClient = msgQueueClient;
  }

  @Override
  protected void doLog(Level level, String mesage) {
    // 格式化 level 和 message, 输出到消息中间件
    msgQueueClient.send(...);
  }
}
```

MessageQueueLogger和FileLogger类各自基础Logger类，继承了3个成员变量`name`,`enabled`,`minPermittedLevel`,由于各自有不同的输入日志的方式，都有复写自己的doLog方法。

  1. 抽象类不允许被实例化，只能被继承
  2. 抽象类可以包含属性和方法
  3. 子类继承抽象类必须实现抽象类的所有抽象方法

+ 如何定义接口

```java

// 接口
public interface Filter {
  void doFilter(RpcRequest req) throws RpcException;
}
// 接口实现类：鉴权过滤器
public class AuthencationFilter implements Filter {
  @Override
  public void doFilter(RpcRequest req) throws RpcException {
    //... 鉴权逻辑..
  }
}
// 接口实现类：限流过滤器
public class RateLimitFilter implements Filter {
  @Override
  public void doFilter(RpcRequest req) throws RpcException {
    //... 限流逻辑...
  }
}
// 过滤器使用 demo
public class Application {
  // filters.add(new AuthencationFilter());
  // filters.add(new RateLimitFilter());
  private List<Filter> filters = new ArrayList<>();

  public void handleRpcRequest(RpcRequest req) {
    try {
      for (Filter filter : fitlers) {
        filter.doFilter(req);
      }
    } catch(RpcException e) {
      // ... 处理过滤结果...
    }
    // ... 省略其他处理逻辑...
  }
}
```

AuthencationFilter和RateLimitFilter通过实现Filter接口分别实现了RPC请求鉴权和限流功能的过滤功能

  1. 接口不能包含属性
  2. 接口只能声明方法，方法不能包含代码实现
  3. 类实现接口的时候，必须实现接口中声明的所有方法

+ 区别
接口和抽象类都有各自的语法特性，抽象类中可以定义属性和方法的实现，接口不能定义属性，方法只能包含签名，抽象类实际是is-a的关系，接口时has-a的关系

### 抽象类和接口能解决什么编程问题

#### 为什么需要抽象类,它解决了什么问题

1. 抽象类解决了代码复用的问题，避免在子类中重复编写相同的代码
2. 基础本身就能达到代码复用的目的，而继承本身也并不要求父类一定是抽象类，但是会失去了多态的特性，没有抽象类的实现优雅。原因有3个

    + 在Logger定义一个空的log方法，虽然解决了继承子类没有log方法问题，但是影响代码的可读性。
    + 创建子类可能忘记重新实现log方法。
    + Logger可以被实例化，并且调用空的log方法，增加了误用的风险

#### 为什么需要接口，它解决了什么问题

1. 接口侧重于解耦，接口是对行为的抽象，相当于一组协议或者契约
2. 可以提高代码的灵活性和扩展性
(后续还会继续讲解)

#### 如何决定该用抽象类还是接口

1. **要表示is-a的关系，并且为了解决代码复用的问题，就用抽象类**
2. **要表示has-a的关系，并且为了解决抽象而非代码复用的问题使用接口**

从继承上看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后抽象成为上层的父类，而接口是自上而下的设计思路，先设计接口，再去考虑具体实现。

## 06为什么基于接口而非实现编程？有必要为每个类都定义接口吗

### 如何解读原则中接口二字

基于接口而非实现编程出自GoF的设计模式一书,它先于很多编程语言而诞生，是条比较抽象和泛化的设计思想

1. 接口是一组协议或者约定，功能提供者提供给使用者的一个功能列表。
2. 在不能层次中都有接口，服务端和客户端，类库，通信协议等，而落实到编程语言中可以理解为接口或者抽象类
3. 越抽象，顶层，脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化，好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然在不破坏原有代码设计的情况下灵活应对

#### 将接口的原则应用到实战中

```java
public class AliyunImageStore {
  //... 省略属性、构造函数等...

  public void createBucketIfNotExisting(String bucketName) {
    // ... 创建 bucket 代码逻辑...
    // ... 失败会抛出异常..
  }

  public String generateAccessToken() {
    // ... 根据 accesskey/secrectkey 等生成 access token
  }

  public String uploadToAliyun(Image image,
           String bucketName, String accessToken) {
    //... 上传图片到阿里云...
    //... 返回图片存储在阿里云上的地址 (url）...
  }

  public Image downloadFromAliyun(String url, String accessToken) {
    //... 从阿里云下载图片...
  }
}

// AliyunImageStore 类的使用举例
public class ImageProcessingJob {
  private static final String BUCKET_NAME = "ai_images_bucket";
  //... 省略其他无关代码...

  public void process() {
    Image image = ...; // 处理图片，并封装为 Image 对象
    AliyunImageStore imageStore = new AliyunImageStore(/* 省略参数 */);
    imageStore.createBucketIfNotExisting(BUCKET_NAME);
    String accessToken = imageStore.generateAccessToken();
    imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);
  }

}
```

上传图片的步骤分为3步:1.创建图片的对应的目录(Bucket),2.获取访问令牌.3.上传图片到阿里云
在代码体现比较清楚，如果随着业务的需求变化，将上传的阿里云改成私有云就会出现需要修改所有调用的地方
所以该代码没有做到抽象，并且暴漏了实现细节给调用者(uploadToAliyun,downloadAliyun),

+ 如何解决这个问题？
  1. 函数的命名不能暴露任何实现细节,`uploadToAliyun`,`downloadAliyun`的命名不符合，需要改成upload,download
  2. 封装具体的实现细节，和阿里云相关的特殊上传或者下载流程不应该暴露给调用者，对上传下载流程进行封装，对外提供一个包裹所有上传下载细节的方法给调用者
  3. 为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议

```java
public interface ImageStore {
  //函数的命名不能暴露任何实现细节
  String upload(Image image, String bucketName);
  Image download(String url);
}

public class AliyunImageStore implements ImageStore {
  //... 省略属性、构造函数等...

  //封装具体的实现细节，和阿里云相关的特殊上传或者下载流程不应该暴露
  //给调用者
  public String upload(Image image, String bucketName) {
    createBucketIfNotExisting(bucketName);
    String accessToken = generateAccessToken();
    //... 上传图片到阿里云...
    //... 返回图片在阿里云上的地址 (url)...
  }

  public Image download(String url) {
    String accessToken = generateAccessToken();
    //... 从阿里云下载图片...
  }

  private void createBucketIfNotExisting(String bucketName) {
    // ... 创建 bucket...
    // ... 失败会抛出异常..
  }

  private String generateAccessToken() {
    // ... 根据 accesskey/secrectkey 等生成 access token
  }
}

// 上传下载流程改变：私有云不需要支持 access token
public class PrivateImageStore implements ImageStore  {
  public String upload(Image image, String bucketName) {
    createBucketIfNotExisting(bucketName);
    //... 上传图片到私有云...
    //... 返回图片的 url...
  }

  public Image download(String url) {
    //... 从私有云下载图片...
  }

  private void createBucketIfNotExisting(String bucketName) {
    // ... 创建 bucket...
    // ... 失败会抛出异常..
  }
}

// ImageStore 的使用举例
public class ImageProcessingJob {
  private static final String BUCKET_NAME = "ai_images_bucket";
  //... 省略其他无关代码...

  public void process() {
    Image image = ...;// 处理图片，并封装为 Image 对象
    ImageStore imageStore = new PrivateImageStore(...);
    imagestore.upload(image, BUCKET_NAME);
  }
}
```

注意:**很多人定义接口的时候，系统通过实现类来反推接口的定义，先把实现类写好写好，然后看实现类中有哪些方法，照抄到接口定义中，导致接口定义不够抽象，依赖具体的实现，接口的设计就没有意义**

#### 是否需要为每个类定义接口

接口的设计初衷是将接口的和实现相分离，封装不问题的实现，暴露问题的接口。如果业务场景中某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那就没有必要设计接口，也没有必要基于接口编程，世界使用实现类就可以了

## 07为何说要多用组合少用继承？如何决定该用组合还是继承

设计原则推荐**组合优于继承，多用组合少用继承。**

### 为什么不推荐继承

+ 继承层次过深，过复杂会影响到代码的可维护性
抽象鸟类，可以按照是否能飞来抽象出CanFlyBird和UnFlyBird类,所有的鸟的实现类就会继承这两个抽象类，继承层次为3，如果后续需要添加描述鸟叫声的功能，分为会叫和不会叫了两种，在CanFlyBird下面新增抽象类CanFlyTweetableBird和CanFlyUntweetableBird，这样继承层次就会增加一层，导致了可读性变成差

### 组合相比继承有哪些优势

根据现实的业务使用继承会导致这些问题，可以使用组合(composition),接口,委托(delegation)3个技术手段解决继承的问题

1. 针对会飞特性定义一个Flyable接口，让会飞的鸟类实现这个接口。如果有其它特性，比如会下蛋，会叫的这些功能也定义成接口，然后实现类根据自身特点实现对应接口

```java

public interface Flyable {
  void fly();
}
public interface Tweetable {
  void tweet();
}
public interface EggLayable {
  void layEgg();
}
public class Ostrich implements Tweetable, EggLayable {// 鸵鸟
  //... 省略其他属性和方法...
  @Override
  public void tweet() { //... }
  @Override
  public void layEgg() { //... }
}
public class Sparrow impelents Flayable, Tweetable, EggLayable {// 麻雀
  //... 省略其他属性和方法...
  @Override
  public void fly() { //... }
  @Override
  public void tweet() { //... }
  @Override
  public void layEgg() { //... }
}
```

### 如何判断该用组合还是继承

## 实战

### 业务开发常用的基于贫血模型的MVC架构违背OOP吗

### 如何利用基于充血模型的DDD开发一个虚拟钱包系统

### 如何对接口鉴权这样一个功能开发做面向对象分析

### 如何利用面向对象设计和编程开发接口鉴权功能
