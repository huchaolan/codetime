# 从Tomcat和Jetty中提炼组件化设计规范

我们每个人获取信息的机会基本上都是平等的，但是为什么有些人对信息理解得更深，并且有自己独到的见解呢？我认为是因为他们养成了思考和总结的好习惯。当我们学习一门技术的时候，如果可以勤于思考、善于总结，可以帮助我们看到现象背后更本质的东西，让我们在成长之路上更快“脱颖而出”

## 组件化及可配置

Tomcat整体架构都是基于组件的，你可以通过XML文件或者代码的方式来配置这些组件，可以在server.xml 配置Tomcat的连接器以及容器组件

Web 容器如何实现这种组件化设计，有两个要点

+ 面向接口编程
系统的功能按照“高内聚、低耦合”的原则进行拆分，每个组件都有相应的接口，组件之间通过接口通信，这样就可以方便地替换组件了。比如我们可以选择不同连接器类型，只要这些连接器组件实现同一个接口就行
+ Web容器提供一个载体把组件组装在一起工作
组件的工作无非就是处理请求，因此容器通过责任链模式把请求依次交给组件去处理。
对用户来说，我只需要告诉Web容器由哪些组件来处理请求。把组件组织起来需要一个“管理者”，这就是为什么Tomcat有一个Server的概念，Server就是组件的载体，Server里包含了连接器组件和容器组件；容器还需要把请求交给各个子容器组件去处理，Tomcat是责任链模式来实现的

Web容器中组件与组件之间的关系是固定的，比如Tomcat中Engine组件下有Host组件、Host组件下有Context组件等，但你不能在Host组件里“注入”一个Wrapper组件，这是由于Web容器本身的功能来决定的

## 组件的创建

组件是可以配置的，Web容器在启动之前并不知道要创建哪些组件，也就是说不能通过硬编码的方式来实例化这些组件，而是需要通过反射机制来动态地创建
Web容器给每个Web应用创建了一个类加载器，Spring用到的类加载器是Web容器传给它的

## 组件的生命周期管理

不同类型的组件具有父子层次关系，父组件处理请求后再把请求传递给某个子组件
Tomcat通过容器的概念，把小容器放到大容器来实现父子关系,
Tomcat采用了类似的办法来管理组件的生命周期,它有两个要点
一是父组件负责子组件的创建、启停和销毁。这样只要启动最上层组件，整个Web容器就被启动起来了，也就实现了一键式启停；
二是Tomcat定义了组件的生命周期状态，并且把组件状态的转变定义成一个事件，一个组件的状态变化会触发子组件的变化，比如Host容器的启动事件里会触发Web应用的扫描和加载，最终会在Host容器下创建相应的Context容器，而Context组件的启动事件又会触发Servlet的扫描，进而创建Wrapper组件。

## 组件的骨架抽象类和模板模式

具体到组件的设计的与实现，Tomcat采用了骨架抽象类和模板模式。比如说Tomcat中 ProtocolHandler接口，ProtocolHandler有抽象基类AbstractProtocol，它实现了协议处理层的骨架和通用逻辑，而具体协议也有抽象基类，比如 HttpProtocol 和 AjpProtocol

这些抽象骨架类实现了一些通用逻辑，并且会定义一些抽象方法，这些抽象方法由子类实现，抽象骨架类调用抽象方法来实现骨架逻辑。是一个通用的设计规范，不管是Web容器还是Spring，甚至JDK本身都到处使用这种设计

